import OpenAI from 'openai';
import { v4 as uuidv4 } from 'uuid';
import { AIResponse, PromptRequest, validateAIResponse } from '../types/contracts.js';
import { Logger } from '../utils/logger.js';
import { EventEmitter } from '../utils/events.js';

export class AIService {
  private openai: OpenAI | null = null;
  private logger = Logger.getInstance();
  private eventEmitter = EventEmitter.getInstance();

  constructor() {
    if (process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY !== 'demo_mode') {
      this.openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
      });
    }
  }

  async generatePlan(request: PromptRequest, correlationId: string): Promise<AIResponse> {
    const startTime = Date.now();
    
    try {
      this.eventEmitter.emit('ai.started', { correlationId, prompt: request.prompt });
      
      let response: AIResponse;
      
      if (this.openai) {
        response = await this.generateWithOpenAI(request, correlationId);
      } else {
        response = await this.generateFallbackResponse(request, correlationId);
      }

      // Validate AI response against schema
      try {
        validateAIResponse(response);
      } catch (validationError) {
        this.logger.warn('AI response validation failed, attempting repair', {
          correlationId,
          error: validationError,
          response
        });
        
        response = await this.repairAIResponse(response, correlationId);
      }

      const processingTime = Date.now() - startTime;
      response.metadata.processingTime = processingTime;

      this.eventEmitter.emit('ai.completed', { 
        correlationId, 
        response: response.summary,
        processingTime 
      });

      return response;
    } catch (error) {
      this.logger.error('AI service error', { correlationId, error });
      this.eventEmitter.emit('error', { 
        correlationId, 
        error: error.message,
        service: 'ai' 
      });
      throw error;
    }
  }

  private async generateWithOpenAI(request: PromptRequest, correlationId: string): Promise<AIResponse> {
    const systemPrompt = this.buildSystemPrompt(request);
    const userPrompt = this.buildUserPrompt(request);

    const completion = await this.openai!.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'gpt-4',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      temperature: 0.1,
      max_tokens: 4000,
      response_format: { type: 'json_object' }
    });

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error('Empty response from OpenAI');
    }

    // Emit token count
    this.eventEmitter.emit('ai.token', {
      correlationId,
      tokens: completion.usage?.total_tokens || 0
    });

    const parsedResponse = JSON.parse(content);
    
    return {
      id: uuidv4(),
      summary: parsedResponse.summary || 'AI-generated plan',
      reasoning: parsedResponse.reasoning || 'Generated by VedxAI',
      plan: parsedResponse.plan || { steps: [] },
      changes: parsedResponse.changes || [],
      notes: parsedResponse.notes || [],
      warnings: parsedResponse.warnings || [],
      metadata: {
        model: completion.model,
        tokens: completion.usage?.total_tokens || 0,
        processingTime: 0, // Will be set by caller
        confidence: parsedResponse.confidence || 0.8
      }
    };
  }

  private async generateFallbackResponse(request: PromptRequest, correlationId: string): Promise<AIResponse> {
    // Enhanced fallback for demo mode
    const prompt = request.prompt.toLowerCase();
    
    let changes: any[] = [];
    let summary = '';
    let reasoning = '';
    let steps: any[] = [];

    if (prompt.includes('component') || prompt.includes('react')) {
      const componentName = this.extractComponentName(request.prompt) || 'NewComponent';
      
      changes = [{
        file: `src/components/${componentName}.tsx`,
        op: 'create',
        applyMethod: 'replaceFile',
        content: this.generateReactComponent(componentName)
      }];
      
      summary = `Created React component: ${componentName}`;
      reasoning = 'Generated a modern React component with TypeScript, hooks, and best practices';
      steps = [
        {
          id: uuidv4(),
          description: `Create ${componentName} component file`,
          type: 'generate',
          status: 'pending'
        }
      ];
    } else if (prompt.includes('api') || prompt.includes('endpoint')) {
      changes = [{
        file: 'src/api/routes.ts',
        op: 'update',
        applyMethod: 'insertAtLine',
        insertAtLine: 10,
        content: this.generateAPIEndpoint(request.prompt)
      }];
      
      summary = 'Added new API endpoint';
      reasoning = 'Generated RESTful API endpoint with proper error handling and validation';
      steps = [
        {
          id: uuidv4(),
          description: 'Add API endpoint to routes',
          type: 'modify',
          status: 'pending'
        }
      ];
    } else {
      // Generic code assistance
      changes = [{
        file: request.context?.currentFile || 'src/utils/helper.ts',
        op: 'update',
        applyMethod: 'insertAtLine',
        insertAtLine: 1,
        content: `// VedxAI Generated Code\n// ${request.prompt}\n\n${this.generateGenericCode(request.prompt)}`
      }];
      
      summary = 'Generated code assistance';
      reasoning = 'Provided code solution based on your request';
      steps = [
        {
          id: uuidv4(),
          description: 'Generate code solution',
          type: 'generate',
          status: 'pending'
        }
      ];
    }

    return {
      id: uuidv4(),
      summary,
      reasoning,
      plan: { steps },
      changes,
      notes: ['This is a fallback response - connect OpenAI API for enhanced results'],
      warnings: request.modes?.maxFilesChanged && changes.length > request.modes.maxFilesChanged 
        ? [`Plan exceeds maxFilesChanged limit (${request.modes.maxFilesChanged})`] 
        : [],
      metadata: {
        model: 'vedx-fallback-v1',
        processingTime: 0,
        confidence: 0.7
      }
    };
  }

  private buildSystemPrompt(request: PromptRequest): string {
    return `You are VedxAI, an advanced AI assistant for VedxBuilder IDE. You help developers by generating comprehensive, actionable plans.

RESPONSE FORMAT: You must respond with valid JSON matching this exact schema:
{
  "summary": "Brief description of what you'll do",
  "reasoning": "Detailed explanation of your approach",
  "plan": {
    "steps": [
      {
        "id": "unique-id",
        "description": "What this step does",
        "type": "analyze|generate|modify|test|deploy",
        "dependencies": ["step-ids-this-depends-on"],
        "estimatedTime": "human-readable estimate"
      }
    ],
    "estimatedDuration": "total time estimate"
  },
  "changes": [
    {
      "file": "relative/path/to/file",
      "op": "create|update|delete|rename",
      "applyMethod": "diff|replaceFile|insertAtLine",
      "content": "full file content for replaceFile",
      "diff": "unified diff for diff method",
      "insertAtLine": 42,
      "newPath": "for rename operations"
    }
  ],
  "notes": ["helpful notes for the user"],
  "warnings": ["important warnings"],
  "confidence": 0.85
}

CONSTRAINTS:
- Maximum ${request.modes?.maxFilesChanged || 10} files can be changed
- Always provide complete, runnable code
- Include proper imports and dependencies
- Follow TypeScript best practices
- Use modern React patterns (hooks, functional components)
- Include error handling and type safety

CONTEXT:
${request.context ? `
- Current file: ${request.context.currentFile || 'none'}
- Open files: ${request.context.openFiles?.join(', ') || 'none'}
- Selected text: ${request.context.selectedText || 'none'}
- Project type: ${request.context.projectType || 'unknown'}
- Framework: ${request.context.framework || 'unknown'}
` : 'No additional context provided'}`;
  }

  private buildUserPrompt(request: PromptRequest): string {
    return `User Request: ${request.prompt}

Please generate a comprehensive plan and implementation for this request. Ensure all code is production-ready and follows best practices.`;
  }

  private async repairAIResponse(response: any, correlationId: string): Promise<AIResponse> {
    // Attempt to repair malformed AI response
    const repaired: AIResponse = {
      id: response.id || uuidv4(),
      summary: response.summary || 'AI-generated plan',
      reasoning: response.reasoning || 'Generated by VedxAI',
      plan: {
        steps: Array.isArray(response.plan?.steps) ? response.plan.steps : [],
        estimatedDuration: response.plan?.estimatedDuration
      },
      changes: Array.isArray(response.changes) ? response.changes : [],
      notes: Array.isArray(response.notes) ? response.notes : ['Response was auto-repaired'],
      warnings: Array.isArray(response.warnings) ? response.warnings : ['AI response required repair'],
      metadata: {
        model: response.metadata?.model || 'unknown',
        tokens: response.metadata?.tokens || 0,
        processingTime: response.metadata?.processingTime || 0,
        confidence: response.metadata?.confidence || 0.5
      }
    };

    this.logger.warn('AI response repaired', { correlationId, original: response, repaired });
    return repaired;
  }

  private extractComponentName(prompt: string): string | null {
    const match = prompt.match(/(?:component|create)\s+(\w+)/i);
    return match ? match[1].charAt(0).toUpperCase() + match[1].slice(1) : null;
  }

  private generateReactComponent(name: string): string {
    return `import React, { useState, useEffect } from 'react';

interface ${name}Props {
  title?: string;
  className?: string;
  onAction?: () => void;
}

const ${name}: React.FC<${name}Props> = ({ 
  title = "Default Title", 
  className = "",
  onAction 
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [data, setData] = useState<any>(null);

  useEffect(() => {
    // Component initialization
    console.log('${name} mounted');
  }, []);

  const handleAction = async () => {
    setIsLoading(true);
    try {
      // Your logic here
      await new Promise(resolve => setTimeout(resolve, 1000));
      onAction?.();
    } catch (error) {
      console.error('${name} error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className={\`${name.toLowerCase()}-container \${className}\`}>
      <h2 className="text-xl font-semibold mb-4">{title}</h2>
      
      <div className="space-y-4">
        <p className="text-gray-600">
          This is the ${name} component generated by VedxAI.
        </p>
        
        <button
          onClick={handleAction}
          disabled={isLoading}
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
        >
          {isLoading ? 'Loading...' : 'Action'}
        </button>
      </div>
    </div>
  );
};

export default ${name};`;
  }

  private generateAPIEndpoint(prompt: string): string {
    const endpoint = this.extractEndpointName(prompt) || 'newEndpoint';
    
    return `
// ${endpoint} endpoint
app.post('/api/${endpoint}', async (req, res) => {
  try {
    const { body } = req;
    
    // Validation
    if (!body) {
      return res.status(400).json({ 
        error: 'Request body is required' 
      });
    }
    
    // Process request
    const result = await process${endpoint.charAt(0).toUpperCase() + endpoint.slice(1)}(body);
    
    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('${endpoint} error:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      message: error.message 
    });
  }
});

async function process${endpoint.charAt(0).toUpperCase() + endpoint.slice(1)}(data: any) {
  // TODO: Implement ${endpoint} logic
  return { processed: true, data };
}`;
  }

  private extractEndpointName(prompt: string): string | null {
    const match = prompt.match(/(?:endpoint|api|route)\s+(?:for\s+)?(\w+)/i);
    return match ? match[1].toLowerCase() : null;
  }

  private generateGenericCode(prompt: string): string {
    return `/**
 * Generated by VedxAI
 * Request: ${prompt}
 */

export function generatedFunction() {
  // TODO: Implement based on: ${prompt}
  console.log('VedxAI generated this code based on your request');
  
  return {
    success: true,
    message: 'Generated by VedxAI',
    timestamp: new Date().toISOString()
  };
}

// Usage example:
// const result = generatedFunction();
// console.log(result);`;
  }

  // TODO: Add support for other AI providers (Anthropic, Google, etc.)
  // TODO: Implement context window management for large codebases
  // TODO: Add fine-tuning support for project-specific patterns
  // TODO: Implement code similarity detection to avoid duplicates
}

export default AIService;